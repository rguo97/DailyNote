# 调试方法
> 1. linux环境中，可以用shell自带的time命令，进行性能测试。示例如下：
> `time go run main.go`
> 2. 通过go自带的调试工具pprof
> CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据
Memory Profile（Heap Profile）：报告程序的内存使用情况
Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈
Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的
> 首先是最基本的runtime/pprof这是官方提供的最基本的包。然后是`net/http/pprof`这个包是封装在`runtime/pprof`这个包基础上的

首先调用runtime/pprof这个包，将结果输出到一份文件中，通过执行go tool pprof <文件名>就可以进行查看，查看性能的消耗。

# 调试工具
## dlv
> dlv是一种专门来调试go代码的工具。首先使用方法，通过ps -ef 找到go运行的二进制文件，然后 dlv attach pid 来进行调试
查看帮助 help，bp，查看断点


# make 和 new
> 在声明一个普通变量的时候，不需要new或者make，只需要通过var声明就可以，但是对于指针类型的变量，在声明的时候要通过new来申请内存空间，但是对于普通的变量，`int`,`string`等变量就不需要new了，但是对于make来说，主要使用的地方有三出，chanel，slice，以及map，使用这三种类型的时候一定要提前通过make申请空间。

# 变量逃逸
> 在go中，变量申请的内存到底是放在堆上还是栈上，是通过go的runtime来自动调度的。一般来说，在某个函数中的临时变量都是分配到栈上的，但是在go中，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆
> 所以说，Golang中一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定。

# 结构体比较
> 只有两个相同类型的结构体才能比较，这个相同类型包括每一个属性的顺序，如果顺序不同，也是两类不同的结构体。

> 如果结构体中存在map，slice。不能简单通过`==`来判断两个结构体是否相同，但是可以通过`reflect.DeepEqua`来比较

# 一个程序运行的流程说明



1. 操作系统把物理硬盘代码load到内存

2. 操作系统把c代码分成四个区

3. 操作系统找到main函数入口执行

## 内存四区


- 栈区(Stack)：
​ 空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区)

- 堆区(heap):
​ 空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。

- 全局区-静态全局变量区:
​ 全局变量的开辟是在程序在main之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用:=赋值会出现编译错误。全局变量最终在进程退出时，由操作系统回收。

    > 我们在开发的时候，尽量减少使用全局变量的设计
- 全局区-常量区：
​ 常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。

> 比如:
const cl = 10
cl是字面量10的对等符号。

所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。

# interface 
> 在go中，interface是一类比较特殊的存在。因为在go中没有像C++、Python中继承以及对象这种概念，但是在编程的过程中，为了简洁、代码复用，方便管理，有不得不有这样的一种东西，所以在go中，就出现了一个特殊的东西，这个东西就是接口interface。
> 其实interface本质上是一组函数的集合，对于某个结构体来说，只有当全部实现了某个接口的全部函数时，我们才会说这个结构体实现了某个接口，少实现一个都不行。结构体是结构体，接口是接口，结构体实现接口。
